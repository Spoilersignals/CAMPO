generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ CONSTANTS ============
// COMMISSION_RATE = 0.15 (15%) - defined in application code

// ============ ENUMS (using String for SQLite compatibility) ============

model User {
  id             String    @id @default(cuid())
  name           String?
  email          String    @unique
  emailVerified  DateTime?
  password       String?
  image          String?
  phone          String?
  phoneVerified  DateTime?
  studentId      String?
  schoolName     String?
  role           String    @default("SELLER") // SELLER, ADMIN
  sellerApproved Boolean   @default(false) // Broker must approve sellers
  isVerified     Boolean   @default(false)
  confessionLink String?   @unique // Personal link code for receiving confessions
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  accounts              Account[]
  sessions              Session[]
  listings              Listing[]
  sales                 Transaction[]       @relation("SellerTransactions")
  sentMessages          ChatMessage[]
  chatThreadsAsSeller   ChatThread[]        @relation("SellerThreads")
  notifications         Notification[]
  reviews               Review[]            @relation("ReviewsReceived")
  reviewsGiven          Review[]            @relation("ReviewsGiven")
  itemRequests          ItemRequest[]
  lostFoundItems        LostFoundItem[]
  reports               Report[]            @relation("ReportsFiled")
  reportsAgainst        Report[]            @relation("ReportsAgainst")
  disputes              Dispute[]
  moderationLogs        ModerationLog[]
  favorites             Favorite[]
  commissionPayments    CommissionPayment[]
  escrowTransactions    EscrowTransaction[]
  rideShares            RideShare[]
  studyGroups           StudyGroup[]
  studyGroupMemberships StudyGroupMember[]
  campusEvents          CampusEvent[]
  eventInterests        EventInterest[]
  receivedConfessions   Confession[]        @relation("ReceivedConfessions")
  followers             Follow[]            @relation("Followers")
  following             Follow[]            @relation("Following")
  receivedQuestions     AnonQuestion[]      @relation("ReceivedQuestions")
  datingProfile         DatingProfile?
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============ MARKETPLACE ============

model Category {
  id           String        @id @default(cuid())
  name         String        @unique
  slug         String        @unique
  parentId     String?
  parent       Category?     @relation("SubCategories", fields: [parentId], references: [id])
  children     Category[]    @relation("SubCategories")
  createdAt    DateTime      @default(now())
  listings     Listing[]
  itemRequests ItemRequest[]
}

// Categories to seed:
// Clothes (parent): Men Wear, Women Wear, Shoes, Bags
// Electronics (parent): TV, Speaker System, Fan, Microwave, Refrigerator, Cooker, Water Heater, Laptops, Phones

model Listing {
  id                  String    @id @default(cuid())
  title               String
  description         String?
  price               Float
  condition           String // NEW, LIKE_NEW, GOOD, FAIR
  usageDuration       String? // Required when condition is not NEW (enforced in app logic)
  deliveryMethod      String // CAMPUS_MEET, HOSTEL_DELIVERY, PICKUP
  pickupLocation      String?
  status              String    @default("PENDING") // PENDING, ACTIVE, SOLD, ARCHIVED, REJECTED
  isFeatured          Boolean   @default(false)
  featuredUntil       DateTime?
  views               Int       @default(0)
  commissionPaid      Boolean   @default(false)
  commissionPaymentId String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  sellerId   String
  seller     User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  photos             ListingPhoto[]
  transactions       Transaction[]
  chatThreads        ChatThread[]
  reports            Report[]
  favorites          Favorite[]
  commissionPayment  CommissionPayment?
  escrowTransactions EscrowTransaction[]

  @@index([status, createdAt])
  @@index([categoryId, status])
  @@index([sellerId])
}

model ListingPhoto {
  id        String   @id @default(cuid())
  url       String
  sortOrder Int      @default(0)
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([listingId])
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  listingId String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
}

// ============ COMMISSION & ESCROW ============

model CommissionPayment {
  id           String    @id @default(cuid())
  amount       Float
  status       String    @default("PENDING") // PENDING, PAID, REFUNDED, HALF_REFUNDED
  listingId    String    @unique
  listing      Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  sellerId     String
  seller       User      @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  paidAt       DateTime?
  refundedAt   DateTime?
  refundAmount Float? // For tracking half refund when sale doesn't happen
  createdAt    DateTime  @default(now())

  @@index([sellerId])
  @@index([status])
}

model EscrowTransaction {
  id         String    @id @default(cuid())
  amount     Float
  status     String    @default("HOLDING") // HOLDING, RELEASED, REFUNDED, DISPUTED
  listingId  String
  listing    Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  buyerName  String
  buyerPhone String
  buyerEmail String?
  sellerId   String
  seller     User      @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  releasedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([sellerId])
  @@index([listingId])
  @@index([status])
}

// ============ CHAT SYSTEM ============

model ChatThread {
  id               String          @id @default(cuid())
  listingId        String?
  listing          Listing?        @relation(fields: [listingId], references: [id], onDelete: SetNull)
  buyerId          String? // Optional for guest buyers
  buyerName        String? // For guest buyers
  buyerPhone       String? // For guest buyers
  buyerEmail       String? // For guest buyers
  sellerId         String
  seller           User            @relation("SellerThreads", fields: [sellerId], references: [id], onDelete: Cascade)
  isModerated      Boolean         @default(true) // Broker can see all
  supportRequested Boolean         @default(false)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  messages         ChatMessage[]
  supportTickets   SupportTicket[]

  @@unique([listingId, buyerId, sellerId])
  @@index([buyerId])
  @@index([sellerId])
}

model ChatMessage {
  id         String     @id @default(cuid())
  body       String
  threadId   String
  thread     ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  senderId   String? // Optional for guest messages
  sender     User?      @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderName String? // For guest buyers
  readAt     DateTime?
  createdAt  DateTime   @default(now())

  @@index([threadId, createdAt])
}

// ============ TRANSACTIONS & REVIEWS ============

model Transaction {
  id          String    @id @default(cuid())
  listingId   String
  listing     Listing   @relation(fields: [listingId], references: [id])
  buyerName   String // Guest buyer name
  buyerPhone  String // Guest buyer phone
  buyerEmail  String? // Guest buyer email
  sellerId    String
  seller      User      @relation("SellerTransactions", fields: [sellerId], references: [id])
  price       Float
  status      String    @default("PENDING") // PENDING, COMPLETED, CANCELLED
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  review   Review?
  disputes Dispute[]

  @@index([sellerId])
}

model Review {
  id            String      @id @default(cuid())
  rating        Int // 1-5
  comment       String?
  transactionId String      @unique
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  reviewerId    String? // Optional - can be from guest
  reviewer      User?       @relation("ReviewsGiven", fields: [reviewerId], references: [id])
  reviewerName  String? // For guest reviewers
  revieweeId    String
  reviewee      User        @relation("ReviewsReceived", fields: [revieweeId], references: [id])
  createdAt     DateTime    @default(now())

  @@index([revieweeId])
}

// ============ ITEM REQUESTS ("Looking For") ============

model ItemRequest {
  id          String   @id @default(cuid())
  title       String
  description String?
  budget      Float?
  condition   String? // Desired condition
  status      String   @default("OPEN") // OPEN, FULFILLED, CLOSED
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  requesterId String? // Optional for anonymous suggestions
  requester   User?    @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  guestName   String? // For anonymous users
  guestEmail  String? // For anonymous users
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  reports Report[]

  @@index([status, createdAt])
}

// ============ LOST & FOUND ============

model LostFoundItem {
  id              String    @id @default(cuid())
  type            String // LOST, FOUND
  title           String
  description     String?
  location        String?
  locationDetails String? // Detailed location where item was found/lost
  contactPhone    String // Phone number to contact
  contactName     String? // Name of person to contact (optional, uses reporter name if not provided)
  occurredAt      DateTime?
  status          String    @default("ACTIVE") // ACTIVE, RESOLVED - FREE feature, no admin review needed
  reporterId      String
  reporter        User      @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  photos  LostFoundPhoto[]
  reports Report[]

  @@index([type, status])
}

model LostFoundPhoto {
  id          String        @id @default(cuid())
  url         String
  sortOrder   Int           @default(0)
  lostFoundId String
  lostFound   LostFoundItem @relation(fields: [lostFoundId], references: [id], onDelete: Cascade)
}

// ============ NOTIFICATIONS ============

model Notification {
  id     String  @id @default(cuid())
  userId String
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type   String // COMMENT, REPLY, REACTION, FOLLOW, MENTION, MESSAGE, LISTING_APPROVED, LISTING_SOLD, etc.
  title  String
  body   String
  link   String? // Where to navigate

  // Reference to what triggered the notification
  commentId    String?
  confessionId String?
  crushId      String?
  spottedId    String?

  isRead    Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId, isRead, createdAt])
  @@index([userId, createdAt])
}

// ============ SUPPORT TICKETS ============

model SupportTicket {
  id          String      @id @default(cuid())
  threadId    String?
  thread      ChatThread? @relation(fields: [threadId], references: [id], onDelete: SetNull)
  subject     String
  description String
  buyerName   String? // For guest buyers
  buyerPhone  String? // For guest buyers
  buyerEmail  String? // For guest buyers
  status      String      @default("OPEN") // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([status])
  @@index([threadId])
}

// ============ REPORTS & DISPUTES ============

model Report {
  id            String         @id @default(cuid())
  targetType    String // LISTING, REQUEST, LOST_FOUND, USER, MESSAGE
  targetId      String
  reason        String
  details       String?
  status        String         @default("PENDING") // PENDING, REVIEWED, RESOLVED
  reporterId    String
  reporter      User           @relation("ReportsFiled", fields: [reporterId], references: [id], onDelete: Cascade)
  againstUserId String?
  againstUser   User?          @relation("ReportsAgainst", fields: [againstUserId], references: [id])
  listingId     String?
  listing       Listing?       @relation(fields: [listingId], references: [id], onDelete: SetNull)
  itemRequestId String?
  itemRequest   ItemRequest?   @relation(fields: [itemRequestId], references: [id], onDelete: SetNull)
  lostFoundId   String?
  lostFound     LostFoundItem? @relation(fields: [lostFoundId], references: [id], onDelete: SetNull)
  handledAt     DateTime?
  createdAt     DateTime       @default(now())

  @@index([status, createdAt])
}

model Dispute {
  id            String      @id @default(cuid())
  transactionId String
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  openedById    String
  openedBy      User        @relation(fields: [openedById], references: [id])
  summary       String
  resolution    String?
  status        String      @default("OPEN") // OPEN, RESOLVED, CLOSED
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([status])
}

model ModerationLog {
  id         String   @id @default(cuid())
  action     String // APPROVE, REJECT, REMOVE, WARN, BAN
  targetType String
  targetId   String
  notes      String?
  adminId    String
  admin      User     @relation(fields: [adminId], references: [id])
  createdAt  DateTime @default(now())

  @@index([targetType, targetId])
}

// ============ ANONYMOUS CONFESSIONS ============

model Confession {
  id               String    @id @default(cuid())
  content          String
  mood             String?
  status           String    @default("PENDING") // PENDING, APPROVED, REJECTED
  confessionNumber Int? // Auto-assigned number for approved confessions
  shareCode        String?   @unique // Short shareable code for public links
  rejectionReason  String?
  recipientId      String? // User who receives this confession (for personal links)
  recipient        User?     @relation("ReceivedConfessions", fields: [recipientId], references: [id])
  createdAt        DateTime  @default(now())
  approvedAt       DateTime?
  expiresAt        DateTime? // For story-style expiration (24h from approval)
  mediaUrl         String? // URL for photo/video
  mediaType        String? // "image" or "video"
  linkUrl          String? // External link URL
  linkTitle        String? // Link preview title
  linkImage        String? // Link preview image

  comments     Comment[] // Unified comment model
  oldComments  ConfessionComment[] // @deprecated - use comments instead
  reactions    ConfessionReaction[]
  views        ConfessionView[]
  hashtagLinks HashtagOnConfession[]
  bookmarks    Bookmark[]
  reposts      Repost[]              @relation("RepostedConfessions")
  battles1     ConfessionBattle[]    @relation("BattleConfession1")
  battles2     ConfessionBattle[]    @relation("BattleConfession2")
  featured     FeaturedContent?

  @@index([status, createdAt])
  @@index([confessionNumber])
  @@index([expiresAt])
  @@index([recipientId])
}

model ConfessionView {
  id           String     @id @default(cuid())
  sessionId    String // Anonymous session ID for tracking unique views
  confessionId String
  confession   Confession @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  viewedAt     DateTime   @default(now())

  @@unique([sessionId, confessionId])
  @@index([confessionId])
}

// @deprecated - Use Comment model instead
model ConfessionComment {
  id           String     @id @default(cuid())
  content      String
  authorName   String? // Optional display name (anonymous if null)
  confessionId String
  confession   Confession @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@index([confessionId, createdAt])
}

model ConfessionReaction {
  id           String     @id @default(cuid())
  emoji        String // üî•üòÇüòÆüò¢üò°‚ù§Ô∏è
  sessionId    String // Anonymous session ID for tracking unique reactions
  confessionId String
  confession   Confession @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@unique([sessionId, confessionId, emoji])
  @@index([confessionId])
}

// ============ PERSONAL CONFESSION LINKS (Anonymous) ============

model PersonalLink {
  id          String   @id @default(cuid())
  sessionId   String   @unique // Browser session ID
  code        String   @unique // Short shareable code
  displayName String? // Optional display name
  createdAt   DateTime @default(now())

  confessions PersonalConfession[]
}

model PersonalConfession {
  id              String       @id @default(cuid())
  content         String
  status          String       @default("RECEIVED") // RECEIVED
  personalLinkId  String
  personalLink    PersonalLink @relation(fields: [personalLinkId], references: [id], onDelete: Cascade)
  sharedToStories Boolean      @default(false)
  createdAt       DateTime     @default(now())

  @@index([personalLinkId, createdAt])
}

// ============ CAMPUS CRUSHES / MISSED CONNECTIONS ============

model CampusCrush {
  id          String    @id @default(cuid())
  title       String // "Blue hoodie guy at library"
  description String // Detailed description
  mood        String?
  location    String? // Where they saw them
  seenAt      DateTime? // When they saw them
  status      String    @default("PENDING") // PENDING, APPROVED, REJECTED
  crushNumber Int? // Auto-assigned number for approved crushes
  createdAt   DateTime  @default(now())
  approvedAt  DateTime?

  comments     Comment[] // Unified comment model
  oldComments  CrushComment[] // @deprecated - use comments instead
  reactions    CrushReaction[]
  hashtagLinks HashtagOnCrush[]
  bookmarks    Bookmark[]
  reposts      Repost[]         @relation("RepostedCrushes")
  featured     FeaturedContent?

  @@index([status, createdAt])
  @@index([crushNumber])
}

// @deprecated - Use Comment model instead
model CrushComment {
  id         String      @id @default(cuid())
  content    String
  authorName String? // Optional display name (anonymous if null)
  crushId    String
  crush      CampusCrush @relation(fields: [crushId], references: [id], onDelete: Cascade)
  createdAt  DateTime    @default(now())

  @@index([crushId, createdAt])
}

model CrushReaction {
  id        String      @id @default(cuid())
  emoji     String // üòçüî•üíïüëÄü•∫
  sessionId String // Anonymous session ID
  crushId   String
  crush     CampusCrush @relation(fields: [crushId], references: [id], onDelete: Cascade)
  createdAt DateTime    @default(now())

  @@unique([sessionId, crushId, emoji])
  @@index([crushId])
}

// ============ SPOTTED (ANONYMOUS SIGHTINGS) ============

model Spotted {
  id            String    @id @default(cuid())
  content       String // What was spotted
  mood          String?
  location      String // Where
  spottedAt     DateTime? // When
  status        String    @default("PENDING") // PENDING, APPROVED, REJECTED
  spottedNumber Int? // Auto-assigned number
  createdAt     DateTime  @default(now())
  approvedAt    DateTime?

  comments     Comment[] // Unified comment model
  oldComments  SpottedComment[] // @deprecated - use comments instead
  reactions    SpottedReaction[]
  hashtagLinks HashtagOnSpotted[]
  bookmarks    Bookmark[]
  reposts      Repost[]           @relation("RepostedSpotted")
  featured     FeaturedContent?

  @@index([status, createdAt])
  @@index([spottedNumber])
}

// @deprecated - Use Comment model instead
model SpottedComment {
  id         String   @id @default(cuid())
  content    String
  authorName String?
  spottedId  String
  spotted    Spotted  @relation(fields: [spottedId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@index([spottedId, createdAt])
}

model SpottedReaction {
  id        String   @id @default(cuid())
  emoji     String
  sessionId String
  spottedId String
  spotted   Spotted  @relation(fields: [spottedId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([sessionId, spottedId, emoji])
  @@index([spottedId])
}

// ============ POLLS & HOT TAKES ============

model Poll {
  id         String    @id @default(cuid())
  question   String
  status     String    @default("PENDING") // PENDING, ACTIVE, CLOSED, REJECTED
  pollNumber Int? // Auto-assigned number
  endsAt     DateTime? // Optional poll end time
  createdAt  DateTime  @default(now())
  approvedAt DateTime?

  options     PollOption[]
  comments    Comment[] // Unified comment model
  oldComments PollComment[] // @deprecated - use comments instead
  bookmarks   Bookmark[]

  @@index([status, createdAt])
}

model PollOption {
  id        String     @id @default(cuid())
  text      String
  pollId    String
  poll      Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes     PollVote[]
  createdAt DateTime   @default(now())

  @@index([pollId])
}

model PollVote {
  id        String     @id @default(cuid())
  sessionId String // Anonymous session ID
  optionId  String
  option    PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())

  @@unique([sessionId, optionId])
  @@index([optionId])
}

// @deprecated - Use Comment model instead
model PollComment {
  id         String   @id @default(cuid())
  content    String
  authorName String?
  pollId     String
  poll       Poll     @relation(fields: [pollId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@index([pollId, createdAt])
}

// ============ UNIFIED COMMENT SYSTEM ============

model Comment {
  id         String  @id @default(cuid())
  content    String
  authorName String? // Optional display name (anonymous if null)
  sessionId  String // For anonymous tracking

  // Polymorphic relations - one of these will be set
  confessionId String?
  confession   Confession?  @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  crushId      String?
  crush        CampusCrush? @relation(fields: [crushId], references: [id], onDelete: Cascade)
  spottedId    String?
  spotted      Spotted?     @relation(fields: [spottedId], references: [id], onDelete: Cascade)
  pollId       String?
  poll         Poll?        @relation(fields: [pollId], references: [id], onDelete: Cascade)

  // Threading - reply to another comment
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  // Reactions on comments
  reactions CommentReaction[]

  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([confessionId, createdAt])
  @@index([crushId, createdAt])
  @@index([spottedId, createdAt])
  @@index([pollId, createdAt])
  @@index([parentId])
  @@index([sessionId])
}

model CommentReaction {
  id        String   @id @default(cuid())
  emoji     String
  sessionId String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([sessionId, commentId, emoji])
  @@index([commentId])
}

// ============ COURSE & PROFESSOR REVIEWS ============

model Course {
  id         String   @id @default(cuid())
  code       String   @unique // e.g., "CS101"
  name       String
  department String?
  createdAt  DateTime @default(now())

  reviews CourseReview[]

  @@index([department])
}

model Professor {
  id         String   @id @default(cuid())
  name       String
  department String?
  createdAt  DateTime @default(now())

  reviews CourseReview[]

  @@index([department])
  @@index([name])
}

model CourseReview {
  id             String     @id @default(cuid())
  rating         Int // 1-5 stars
  difficulty     Int? // 1-5 (1=easy, 5=hard)
  workload       Int? // 1-5 (1=light, 5=heavy)
  content        String? // Review text
  grade          String? // Grade received (optional)
  wouldTakeAgain Boolean?
  tips           String? // Tips for future students
  semester       String? // e.g., "Fall 2024"
  isAnonymous    Boolean    @default(true)
  authorName     String? // Display name if not anonymous
  sessionId      String // For anonymous tracking
  courseId       String
  course         Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  professorId    String?
  professor      Professor? @relation(fields: [professorId], references: [id], onDelete: SetNull)
  createdAt      DateTime   @default(now())

  @@index([courseId])
  @@index([professorId])
}

// ============ RIDE SHARING ============

model RideShare {
  id             String   @id @default(cuid())
  type           String // OFFERING, LOOKING
  origin         String // From where
  destination    String // To where
  departureDate  DateTime
  departureTime  String? // Flexible time description
  seatsAvailable Int? // For OFFERING
  seatsNeeded    Int? // For LOOKING
  pricePerSeat   Float?
  description    String?
  contactPhone   String
  contactName    String?
  status         String   @default("ACTIVE") // ACTIVE, FULL, CANCELLED, COMPLETED
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([type, status, departureDate])
  @@index([userId])
}

// ============ STUDY GROUPS ============

model StudyGroup {
  id          String    @id @default(cuid())
  courseCode  String // Course code this group is for
  courseName  String?
  topic       String? // Specific topic/exam to study
  location    String? // Where to meet
  meetingTime DateTime?
  maxMembers  Int?
  description String?
  contactInfo String // How to join/contact
  status      String    @default("OPEN") // OPEN, FULL, CLOSED
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  members StudyGroupMember[]

  @@index([courseCode, status])
  @@index([userId])
}

model StudyGroupMember {
  id           String     @id @default(cuid())
  studyGroupId String
  studyGroup   StudyGroup @relation(fields: [studyGroupId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt     DateTime   @default(now())

  @@unique([studyGroupId, userId])
}

// ============ CAMPUS EVENTS ============

model CampusEvent {
  id          String    @id @default(cuid())
  title       String
  description String?
  location    String
  startTime   DateTime
  endTime     DateTime?
  category    String // PARTY, CLUB, ACADEMIC, SPORTS, CAREER, OTHER
  imageUrl    String?
  ticketPrice Float? // null = free
  ticketLink  String? // External ticket link
  contactInfo String?
  status      String    @default("PENDING") // PENDING, APPROVED, REJECTED, CANCELLED
  isFeatured  Boolean   @default(false)
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  interested EventInterest[]

  @@index([status, startTime])
  @@index([category, status])
  @@index([userId])
}

model EventInterest {
  id        String      @id @default(cuid())
  eventId   String
  event     CampusEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime    @default(now())

  @@unique([eventId, userId])
}

// ============ ANONYMOUS GROUP CHAT ============

model GroupChatMessage {
  id          String             @id @default(cuid())
  content     String
  authorName  String? // Optional display name (anonymous if null)
  sessionId   String // For message ownership/deletion
  anonymousId String             @default("Anon#0000") // Unique anonymous identity per session (e.g., "Anon#1234")
  replyToId   String? // Optional reference to message being replied to
  replyTo     GroupChatMessage?  @relation("Replies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies     GroupChatMessage[] @relation("Replies")
  isDeleted   Boolean            @default(false)
  deletedAt   DateTime?
  deletedBy   String? // "OWNER" or "ADMIN"
  createdAt   DateTime           @default(now())

  @@index([createdAt])
  @@index([sessionId])
}

// Banned words for group chat (selling prevention)
model BannedWord {
  id        String   @id @default(cuid())
  word      String   @unique
  createdAt DateTime @default(now())
}

// ============ PUSH NOTIFICATIONS ============

model PushSubscription {
  id        String   @id @default(cuid())
  endpoint  String   @unique
  p256dh    String
  auth      String
  userId    String?
  sessionId String
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([sessionId])
}

// ============ HASHTAGS & TRENDING ============

model Hashtag {
  id        String   @id @default(cuid())
  name      String   @unique // lowercase, no #
  postCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  confessions HashtagOnConfession[]
  spotted     HashtagOnSpotted[]
  crushes     HashtagOnCrush[]

  @@index([postCount])
}

model HashtagOnConfession {
  id           String     @id @default(cuid())
  hashtagId    String
  hashtag      Hashtag    @relation(fields: [hashtagId], references: [id], onDelete: Cascade)
  confessionId String
  confession   Confession @relation(fields: [confessionId], references: [id], onDelete: Cascade)

  @@unique([hashtagId, confessionId])
}

model HashtagOnSpotted {
  id        String  @id @default(cuid())
  hashtagId String
  hashtag   Hashtag @relation(fields: [hashtagId], references: [id], onDelete: Cascade)
  spottedId String
  spotted   Spotted @relation(fields: [spottedId], references: [id], onDelete: Cascade)

  @@unique([hashtagId, spottedId])
}

model HashtagOnCrush {
  id        String      @id @default(cuid())
  hashtagId String
  hashtag   Hashtag     @relation(fields: [hashtagId], references: [id], onDelete: Cascade)
  crushId   String
  crush     CampusCrush @relation(fields: [crushId], references: [id], onDelete: Cascade)

  @@unique([hashtagId, crushId])
}

model TrendingSnapshot {
  id        String   @id @default(cuid())
  hashtagId String
  rank      Int
  postCount Int
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// ============ BOOKMARKS ============

model Bookmark {
  id           String       @id @default(cuid())
  sessionId    String
  contentType  String // confession, crush, spotted, poll
  confessionId String?
  confession   Confession?  @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  crushId      String?
  crush        CampusCrush? @relation(fields: [crushId], references: [id], onDelete: Cascade)
  spottedId    String?
  spotted      Spotted?     @relation(fields: [spottedId], references: [id], onDelete: Cascade)
  pollId       String?
  poll         Poll?        @relation(fields: [pollId], references: [id], onDelete: Cascade)
  createdAt    DateTime     @default(now())

  @@unique([sessionId, contentType, confessionId])
  @@unique([sessionId, contentType, crushId])
  @@unique([sessionId, contentType, spottedId])
  @@unique([sessionId, contentType, pollId])
  @@index([sessionId])
}

// ============ REPOSTS & QUOTES ============

model Repost {
  id                   String       @id @default(cuid())
  sessionId            String
  quoteText            String? // Optional quote/comment
  originalType         String // confession, crush, spotted
  originalConfessionId String?
  originalConfession   Confession?  @relation("RepostedConfessions", fields: [originalConfessionId], references: [id], onDelete: Cascade)
  originalCrushId      String?
  originalCrush        CampusCrush? @relation("RepostedCrushes", fields: [originalCrushId], references: [id], onDelete: Cascade)
  originalSpottedId    String?
  originalSpotted      Spotted?     @relation("RepostedSpotted", fields: [originalSpottedId], references: [id], onDelete: Cascade)
  createdAt            DateTime     @default(now())

  @@index([sessionId])
  @@index([createdAt])
}

// ============ ANONYMOUS PERSONAS ============

model AnonymousPersona {
  id        String   @id @default(cuid())
  sessionId String   @unique
  avatar    String // emoji or avatar identifier
  alias     String // fun random name like "MysticPanda42"
  color     String // hex color for their posts
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============ STREAKS ============

model UserStreak {
  id            String    @id @default(cuid())
  sessionId     String    @unique
  currentStreak Int       @default(0)
  longestStreak Int       @default(0)
  lastPostDate  DateTime?
  totalPosts    Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ============ CONFESSION BATTLES ============

model ConfessionBattle {
  id            String     @id @default(cuid())
  confession1Id String
  confession1   Confession @relation("BattleConfession1", fields: [confession1Id], references: [id], onDelete: Cascade)
  confession2Id String
  confession2   Confession @relation("BattleConfession2", fields: [confession2Id], references: [id], onDelete: Cascade)
  status        String     @default("ACTIVE") // ACTIVE, ENDED
  endsAt        DateTime
  winner1Votes  Int        @default(0)
  winner2Votes  Int        @default(0)
  createdAt     DateTime   @default(now())

  votes BattleVote[]

  @@index([status, endsAt])
}

model BattleVote {
  id        String           @id @default(cuid())
  sessionId String
  battleId  String
  battle    ConfessionBattle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  votedFor  Int // 1 or 2
  createdAt DateTime         @default(now())

  @@unique([sessionId, battleId])
}

// ============ ANONYMOUS Q&A ============

model AnonQuestion {
  id              String   @id @default(cuid())
  question        String
  recipientId     String? // If asking a user
  recipient       User?    @relation("ReceivedQuestions", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientCode   String? // If asking via personal link
  senderSessionId String
  status          String   @default("PENDING") // PENDING, ANSWERED, IGNORED
  createdAt       DateTime @default(now())

  answer AnonAnswer?

  @@index([recipientId, status])
  @@index([recipientCode])
}

model AnonAnswer {
  id         String       @id @default(cuid())
  questionId String       @unique
  question   AnonQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  content    String
  isPublic   Boolean      @default(true)
  createdAt  DateTime     @default(now())
}

// ============ SECRET ADMIRERS ============

model SecretAdmirer {
  id         String   @id @default(cuid())
  sessionId  String
  targetCode String // Personal link code of the person they admire
  message    String? // Optional anonymous message
  revealed   Boolean  @default(false)
  createdAt  DateTime @default(now())

  @@unique([sessionId, targetCode])
  @@index([targetCode])
}

// ============ FEATURED CONTENT ============

model FeaturedContent {
  id           String       @id @default(cuid())
  contentType  String // confession, crush, spotted
  confessionId String?      @unique
  confession   Confession?  @relation(fields: [confessionId], references: [id], onDelete: Cascade)
  crushId      String?      @unique
  crush        CampusCrush? @relation(fields: [crushId], references: [id], onDelete: Cascade)
  spottedId    String?      @unique
  spotted      Spotted?     @relation(fields: [spottedId], references: [id], onDelete: Cascade)
  featuredDate DateTime     @default(now())
  reason       String? // "Most reactions", "Editor's pick", etc.

  @@index([featuredDate])
}

// ============ LEADERBOARDS ============

model LeaderboardEntry {
  id          String    @id @default(cuid())
  sessionId   String
  category    String // top_poster, funniest, most_helpful, streak_master
  score       Int       @default(0)
  rank        Int?
  period      String // weekly, monthly, alltime
  periodStart DateTime
  periodEnd   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([sessionId, category, period, periodStart])
  @@index([category, period, score])
}

// ============ DATING / CAMPUS MATCH ============

model DatingProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Basic Info
  displayName String
  bio         String?
  age         Int
  gender      String // MALE, FEMALE, NON_BINARY, OTHER
  lookingFor  String[] // Array of genders they're interested in

  // Academic Info
  course      String?
  yearOfStudy Int?
  faculty     String?

  // Interests & Lifestyle
  interests        String[] // Array of interest tags
  height           String? // e.g., "5'10" or "178cm"
  relationshipGoal String? // RELATIONSHIP, CASUAL, FRIENDS, NOT_SURE

  // Social Links
  instagramHandle String?
  spotifyArtists  String? // Favorite artists

  // Prompts/Icebreakers
  prompt1Question String?
  prompt1Answer   String?
  prompt2Question String?
  prompt2Answer   String?
  prompt3Question String?
  prompt3Answer   String?

  // Preferences
  minAge      Int     @default(18)
  maxAge      Int     @default(30)
  maxDistance Int? // in km, null = no limit
  showMe      Boolean @default(true) // Whether to show in discovery

  // Stats
  superLikesRemaining Int      @default(3)
  lastSuperLikeReset  DateTime @default(now())
  profileCompleteness Int      @default(0) // 0-100 percentage

  isActive   Boolean  @default(true)
  isVerified Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  photos         DatingPhoto[]
  sentSwipes     DatingSwipe[]   @relation("SentSwipes")
  receivedSwipes DatingSwipe[]   @relation("ReceivedSwipes")
  matches1       DatingMatch[]   @relation("MatchUser1")
  matches2       DatingMatch[]   @relation("MatchUser2")
  sentMessages   DatingMessage[]
  reports        DatingReport[]  @relation("ReportedProfiles")
  reportsMade    DatingReport[]  @relation("ReportsMade")
  blocks         DatingBlock[]   @relation("BlockedProfiles")
  blockedBy      DatingBlock[]   @relation("BlockedBy")

  @@index([gender])
  @@index([isActive, showMe])
}

model DatingPhoto {
  id              String        @id @default(cuid())
  url             String
  sortOrder       Int           @default(0)
  isMain          Boolean       @default(false)
  datingProfileId String
  datingProfile   DatingProfile @relation(fields: [datingProfileId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())

  @@index([datingProfileId])
}

model DatingSwipe {
  id        String        @id @default(cuid())
  swiperId  String
  swiper    DatingProfile @relation("SentSwipes", fields: [swiperId], references: [id], onDelete: Cascade)
  swipedId  String
  swiped    DatingProfile @relation("ReceivedSwipes", fields: [swipedId], references: [id], onDelete: Cascade)
  type      String // LIKE, PASS, SUPER_LIKE
  createdAt DateTime      @default(now())

  @@unique([swiperId, swipedId])
  @@index([swipedId, type])
}

model DatingMatch {
  id         String        @id @default(cuid())
  profile1Id String
  profile1   DatingProfile @relation("MatchUser1", fields: [profile1Id], references: [id], onDelete: Cascade)
  profile2Id String
  profile2   DatingProfile @relation("MatchUser2", fields: [profile2Id], references: [id], onDelete: Cascade)

  isActive      Boolean   @default(true) // false if unmatched
  matchedAt     DateTime  @default(now())
  lastMessageAt DateTime?

  messages DatingMessage[]

  @@unique([profile1Id, profile2Id])
  @@index([profile1Id, isActive])
  @@index([profile2Id, isActive])
}

model DatingMessage {
  id        String        @id @default(cuid())
  matchId   String
  match     DatingMatch   @relation(fields: [matchId], references: [id], onDelete: Cascade)
  senderId  String
  sender    DatingProfile @relation(fields: [senderId], references: [id], onDelete: Cascade)
  content   String
  isRead    Boolean       @default(false)
  createdAt DateTime      @default(now())

  @@index([matchId, createdAt])
}

model DatingReport {
  id         String        @id @default(cuid())
  reporterId String
  reporter   DatingProfile @relation("ReportsMade", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedId String
  reported   DatingProfile @relation("ReportedProfiles", fields: [reportedId], references: [id], onDelete: Cascade)
  reason     String // INAPPROPRIATE_PHOTOS, HARASSMENT, FAKE_PROFILE, SPAM, OTHER
  details    String?
  status     String        @default("PENDING") // PENDING, REVIEWED, ACTIONED
  createdAt  DateTime      @default(now())

  @@index([status])
}

model DatingBlock {
  id        String        @id @default(cuid())
  blockerId String
  blocker   DatingProfile @relation("BlockedProfiles", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedId String
  blocked   DatingProfile @relation("BlockedBy", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt DateTime      @default(now())

  @@unique([blockerId, blockedId])
}
